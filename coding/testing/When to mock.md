# When to Mock

## Author: Uncle Bob

### Tags: 

@coding

[ref](https://blog.cleancoder.com/uncle-bob/2014/05/10/WhenToMock.html)

### Questions

- Are you mocking architectural boundaries (good) or class to class interactions (bad)?

- Are you mocking when you shouldn't?

### Content

### Too Many Mocks, this is the common mistake

Consider a large web application, but this time with a test suite that imposes mocks between all the classes. What problems will it face?

Ironically, some mocking systems depend strongly on reflection, and are therefore very slow. When you mock out the interaction between two classes with something slower than those two classes, you can pay a pretty hefty price.

Mocking the interactions between all classes forces you to create mocks that return other mocks (that might return yet other mocks). You have to mock out all the data pathways in the interaction; and that can be a complex task. This creates two problems.

- The setup code can get extremely complicated.
- The mocking structure become tightly coupled to implementation details causing many tests to break when those details are modified.
- The need to mock every class interaction forces an explosion of polymorphic interfaces. In statically typed languages like Java, that means the creation of lots of extra interface classes whose sole purpose is to allow mocking. This is over-abstraction and the dreaded “design damage”.

So if you mock too much you may wind up with test suites that are slow, fragile, and complicated; and you may also damage the design of your application.

### Goldilocks Mocks (Not too Few, Not too many)

> Mock across architecturally significant boundaries, but not within those boundaries.

For example, mock out the database, web server, and any external service. This provides many benefits:

- The tests run much faster.
- The tests are not sensitive to failures and configurations of the mocked out components.
- It is easy to test all the failure scenarios generated by the mocked out components.
- Every pathway of coupled finite state machines across that boundary can be tested.
- You generally don’t create mocks that return other mocks, so your setup code stays much cleaner.